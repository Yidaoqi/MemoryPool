> 翻译来自机翻



该代码库已不再维护。
-------

我不再使用C++编程或遵循标准，因此将来不会更新该代码库。多年来只有少数几个小问题出现，我认为MemoryPool是稳定的，仍然是你自己实现的一个很好的起点。或者，你可以使用众多的分支之一。

内存池
==========

这是一个非常简单易用且速度极快、每次分配/释放的开销极小的内存池分配器的模板类实现。提供的类在大多数情况下与C++标准库兼容，但也有一些例外（详见[C++兼容性](#c-compliance)）。

该库使用可变参数模板进行完美的参数转发和其他一些优化，因此需要C++11特性。也有一个C++98版本，但C++11版本具有更好的内存管理。

什么是内存池
-------------------------

在C/C++中，通常使用`malloc`或`new`进行动态内存管理。这些函数速度较慢，并且附带一些内存开销。如果您只进行少量调用并请求大块内存，这是可以接受的，但如果您需要存储许多小对象，则时间和内存开销可能无法满足高性能程序的要求。这就是内存池的作用。
内存池将内存分配为大块，并将内存分割为较小的片段。每次请求内存时，将返回其中一个小块，而不是调用操作系统或堆分配器。只有在事先知道对象的大小时，才能使用内存池，但是如果知道，内存池具有许多优点：

* 它比`malloc`或`new`快得多
* 由于每个对象的大小事先已知（即不需要存储分配元数据），几乎没有内存开销。
* 几乎没有内存碎片化。
* 你不需要逐个释放对象。分配器会在其析构函数被调用时释放它所分配的所有内存。请注意，这仅在对象具有默认析构函数时有效。

内存池只有一些缺点：

* 对象具有固定的大小，必须事先知道。这通常不是问题，大多数情况下，如果你需要一次性分配它们，这种情况会发生。
* 你可能需要根据你的特定应用进行微调。使用模板类可以非常容易地实现这一点。

何时使用
-------------------------

当需要分配许多相同大小的对象时，应该使用内存池。当您实现常见的数据结构(如链表、二叉搜索树、带链的散列表等)时，通常会出现这种情况。在这些情况下使用内存池将使性能提高几倍，并大大减少内存浪费。

C++ Compliance
-------------------------

MemoryPool基本上与c++标准库分配器兼容。这意味着你可以使用`allocator_traits` ([见这里](http://www.cplusplus.com/reference/memory/allocator_traits/))或就像你会使用' std::allocator '([见这里](http://www.cplusplus.com/reference/memory/allocator/))。不过也有一些不同之处:

* MemorPool **不能** *用一个调用' allocate '来分配多个对象，它会简单地忽略你传递给allocate/deallocate函数的count值。修复这个问题并不太难，但它会降低性能并造成内存碎片。
  这是**不**线程安全的。您应该为每个线程创建一个不同的实例(建议)，或者找到对分配器调度查询的某种方法。
* 

使用
-------------------------

放上' MemoryPool.h '和' MemoryPool '。将“MemoryPool.h”包含到项目文件夹中。不要忘记启用c++11的特性(例如，如果使用GCC，使用' -std=c++11 '标志)。这些文件在通用命名空间中定义了一个模板类:

```C
template<typename T, size_t BlockSize = 4096>
```

这里，`T`是你想要分配的对象的类型，`BlockSize`是内存池分配的块的大小(参见[pick BlockSize] (#pick - BlockSize)了解更多信息)。' T '可以是任何对象，而' BlockSize '需要至少是' T '大小的两倍。之后，您将创建' MemoryPool '类的实例，并像使用标准分配器对象一样使用它。下面是一个例子:

```cpp
#include <iostream>
#include "MemoryPool.h"

int main()
{
  MemoryPool<size_t> pool;
  size_t* x = pool.allocate();

  *x = 0xDEADBEEF;
  std::cout << std::hex << *x << std::endl;

  pool.deallocate(x);
  return 0;
}
```

通常，如果`T`是一个具有非默认构造函数的类，则需要在使用之前对返回的指针调用`MemoryPool.construct(pointer)`，然后调用' MemoryPool.destroy(pointer) '。除了标准的分配器函数，MemoryPool还定义了两个新函数:`newElement(Args…)`和`deleteElement(pointer)`。这些函数的行为就像标准的' new '和' delete '函数一样，并且不需要分别调用构造函数和析构函数。唯一的区别是它们只能为类型`T`对象分配空间。我们可以使用这些函数重写上面的代码(我们没有使用它们，因为`size_t`不需要构造):

```cpp
#include <iostream>
#include "MemoryPool.h"

int main()
{
  MemoryPool<size_t> pool;
  size_t* x = pool.newElement();

  *x = 0xDEADBEEF;
  std::cout << std::hex << *x << std::endl;

  pool.deleteElement(x);
  return 0;
}
```

`newElement`中的`Args`是你传递给`T`构造函数的任何参数(c++ 11完美转发的魔力)。

有关更多信息，请参阅[allocator_traits](http://www.cplusplus.com/reference/memory/allocator_traits/)或[标准分配器](http://www.cplusplus.com/reference/memory/allocator/)的参考。

代码中提供了更多示例。

挑选BlockSize
-------------------------

`BlockSize`是分配器向系统请求的块的大小(以字节为单位)。它必须足够大，至少可以包含两个指针或两个`T`对象，这取决于哪个更大。

选择正确的`BlockSize`对于良好的性能至关重要。我建议您选择2的幂，这可能会减少内存碎片，具体取决于您的系统。此外，确保`BlockSize`至少比`T`的大小大数百倍，以获得最大性能。这个想法是,`BlockSize`越大，对`malloc`的调用就越少。但是，选择太大的大小可能会增加不必要的内存使用，并且实际上会降低性能，因为`malloc`可能需要进行许多系统调用。

对于包含多个指针的对象，默认大小为4096字节应该是合适的。如果你需要更大的对象，你可能需要用更大的尺寸来计时你的代码，看看什么效果最好。除非您要维护许多`MemoryPool`对象，否则我认为您不需要小于`4096`字节。但是，如果您在更有限的平台上工作(具有支持c++ 11的编译器)，则可能需要使用较小的值。

关于守则
-------------------------

这里有一些关于代码你应该知道的要点:

*此代码自动处理对象对齐，这对于高性能内存访问是必要的，甚至可能在某些处理器上是必需的。然而，它假设' operator new '返回的内存“足够对齐”以存储指针。这个假设是不必要的，但由于它足够合理，我决定删除两行代码。我不确定这是否是标准所要求的，但如果不是这种情况，所有使用' malloc '的C代码都会崩溃(或运行得非常慢)。

分配器不会释放任何内存，直到它被销毁(尽管它会重用你释放的内存)。如果您只分配对象，或者您同样频繁地分配和重新分配对象，这是可以的。只有当您有高内存使用的峰值，并且您希望在低内存期间释放内存时，才会出现这个问题。这是大幅度提高性能的设计选择，在大多数情况下您不需要担心这个问题。但是，对于需要对内存进行特殊处理的项目来说，记住这一点是很好的。
